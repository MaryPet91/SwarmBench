// Generated by MODEX Version 2.10 - 25 June 2016
// lun  4 feb 2019, 18.53.12, CET from mutex2.c

# 1 "_modex_.drv"
# 1 "<built-in>"
# 1 "<command-line>"
# 31 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 32 "<command-line>" 2
# 1 "_modex_.drv"
# 1 "_modex_.h" 1
 c_state "long res_p_main" "Global"
bool lck_p_main_ret;
bool lck_p_main;
 c_state "long res_p_increment" "Global"
bool lck_p_increment_ret;
bool lck_p_increment;
 c_state "long res_p_watch" "Global"
bool lck_p_watch_ret;
bool lck_p_watch;
int count_max;
int count_mutex;
int count = 0;
chan ret_p_main = [1] of { pid };
chan exc_cll_p_main = [0] of { pid };
chan req_cll_p_main = [1] of { pid };
chan ret_p_increment = [1] of { pid };
chan exc_cll_p_increment = [0] of { pid };
chan req_cll_p_increment = [1] of { pid };
chan ret_p_watch = [1] of { pid };
chan exc_cll_p_watch = [0] of { pid };
chan req_cll_p_watch = [1] of { pid };
# 2 "_modex_.drv" 2
# 1 "_modex_all.pml" 1
active proctype p_watch()
{
# 1 "_modex_all_0.h" 1
pid lck_id;
# 9 "_modex_all.pml" 2
endRestart:
 atomic {
 nempty(req_cll_p_watch) && !lck_p_watch -> lck_p_watch = 1;
 req_cll_p_watch?lck_id; exc_cll_p_watch?eval(lck_id);
 lck_p_watch = 0;
 };
    atomic { c_expr { spin_mutex_free(&(now.count_mutex)) }; c_code { spin_mutex_lock(&(now.count_mutex)); }; };
L_0:
    do
    :: c_expr { (now.count<=30) };
        byte wait_var_1
L_wait_1:
 c_code { Pp_watch->wait_var_1 = spin_cond_wait(&(now.count_max), &(now.count_mutex)); }
 if
 :: c_expr { (Pp_watch->wait_var_1 == 0) }
    atomic { c_expr { spin_mutex_free(&(now.count_mutex)) }
   c_code { spin_mutex_lock(&(now.count_mutex)); } }
   goto L_wait_1
 :: else
 fi
    goto L_0;
    :: c_expr { !(now.count<=30) }; -> break
    od;
    c_code { spin_mutex_unlock(&(now.count_mutex)); };
Return: skip;
 ret_p_watch!lck_id;
 goto endRestart
}
active proctype p_increment()
{
# 1 "_modex_all_1.h" 1
int i;
pid lck_id;
# 56 "_modex_all.pml" 2
endRestart:
 atomic {
 nempty(req_cll_p_increment) && !lck_p_increment -> lck_p_increment = 1;
 req_cll_p_increment?lck_id; exc_cll_p_increment?eval(lck_id);
 lck_p_increment = 0;
 };
    c_code { Pp_increment->i=0; };
L_1:
    do
    :: c_expr { (Pp_increment->i<20) };
        atomic { c_expr { spin_mutex_free(&(now.count_mutex)) }; c_code { spin_mutex_lock(&(now.count_mutex)); }; };
c_code { now.count++; };
        c_code { spin_cond_signal(&(now.count_max)); };
        c_code { spin_mutex_unlock(&(now.count_mutex)); };
c_code { Pp_increment->i++; };
    goto L_1;
c_code { Pp_increment->i++; };
    :: c_expr { !(Pp_increment->i<20) }; -> break
    od;
Return: skip;
 ret_p_increment!lck_id;
 goto endRestart
}
active proctype p_main()
{
# 1 "_modex_all_2.h" 1
int threads[3];
int i;
pid lck_id;
# 98 "_modex_all.pml" 2
# 109 "_modex_all.pml"
    c_code { spin_mutex_init(&(now.count_mutex),NULL); };
    c_code { spin_mutex_init(&(now.count_max),NULL); };
     atomic {
  lck_p_increment == 0 && empty(req_cll_p_increment) -> req_cll_p_increment!_pid;
  exc_cll_p_increment!_pid;
 }
     atomic {
  lck_p_increment == 0 && empty(req_cll_p_increment) -> req_cll_p_increment!_pid;
  exc_cll_p_increment!_pid;
 }
     atomic {
  lck_p_watch == 0 && empty(req_cll_p_watch) -> req_cll_p_watch!_pid;
  exc_cll_p_watch!_pid;
 }
     ret_p_increment?eval(_pid);
 c_code { now.lck_p_increment_ret = 0; };
     ret_p_increment?eval(_pid);
 c_code { now.lck_p_increment_ret = 0; };
     ret_p_watch?eval(_pid);
 c_code { now.lck_p_watch_ret = 0; };
Return: skip;
# 158 "_modex_all.pml"
}
# 2 "_modex_.drv" 2
